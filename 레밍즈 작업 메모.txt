// 앞쪽 발 위치는 캐릭터의 방향만큼 1픽셀
ind dir = (walkingRight ? 1 : -1 );


 // 방향값 포함 발바닥 중앙 좌표 // 윈도우는 기본 좌상단 (0,0)부터 그려지니까, 중앙 기준으로 맞춰준 것.
Vector posBase
posBase += Vector (spriteWidth / 2 + dir,  spriteHeight - 1) // 스프라이트 그려지는 끝점 바로 이전 좌표

posBase를 충돌검사하고

Vector mapRightWallCollisionPos = Vector(nextPos.x + (spriteWidth / 2 - 1)
Vector mapLeftWallCollisionPos = Vector(nextPos.x + (-spriteWidth / 2) * scale)

y값은 y < spriteHeight / 2 - n 으로  발바닥 높이 기준으로, 해당 높이에서의 위 x값 위치가 땅이랑 닿으면

벽 충돌 되긴 하는데,

레밍 영상을 보니까 경계선위에서 걷고
내 버전에선 



현재 스프라이트 픽셀 존재를 확인하는 로직은
1. 스프라이트 센터 기준으로 좌/우 위/아래로 오프셋만큼 x, y 값을 순회해서
 Vector lemmingTexturePos 좌표로 넣음
2. lemmingCollisionPos = 1번의 lemmingTexturePos
3. 원본(비트맵)의 유효한 픽셀 확인 = [y * width + x] ! = 0
4. 각 y와 x 값은 lemmingCollisionPos의 값을 넣어주고 3번 공식을 if문으로 사용. 성립 시 맵과 충돌 체크
5. 맵 충돌도 순회하는 오프셋(간격) 만큼 nextPos에 더해줌
 Vector mapCollisionPos = Vector(nextPos.x + (x*3), nextPos.y + (y*3) // 레밍 생성할 때 원본 비율에서 각각 3배씩 늘린 상태
(월드 좌표에서늘어난 만큼)

스프라이트 크기는 RECT 또는 SIZE로 관리


	// 화면 경계 체크
	//if (_pos.x < 400) 
	//{ 
	//	_walkingRight = true; 
	//	_sprite = _spriteMoveRight;
	//	_pos.x = 400; 
	//}
	//
	//if (_pos.x > 500) 
	//{
	//	_pos.x = 500; 
	//	_walkingRight = false; 
	//	_sprite = _spriteMoveLeft;

	//}